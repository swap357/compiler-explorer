# Numba Support in Compiler Explorer

Compiler Explorer supports viewing JIT-compiled assembly from Python code using [Numba](https://numba.pydata.org/), a high-performance Python compiler that uses LLVM to generate optimized machine code.

## Overview

When you write Python code with Numba decorators (like `@numba.jit` or `@numba.njit`), Compiler Explorer will:
1. Execute your Python code to trigger JIT compilation
2. Extract the generated assembly from Numba's compiled functions
3. Display the native assembly code with source line mapping

## Basic Usage

### Simple Example

```python
import numba

@numba.njit
def add(a, b):
    return a + b
```

This will show the optimized assembly generated by Numba's JIT compiler, typically very efficient code like:
```asm
add:
  addl %esi, %edi
  movl %edi, (%rdi)
  xorl %eax, %eax
  retq
```

### Type Signatures

You can specify explicit type signatures for better control:

```python
import numba

@numba.njit("int32(int32, int32)")
def multiply(x, y):
    return x * y
```

## Features

### Vectorization

```python
import numba
import numpy as np

@numba.njit
def vector_sum(arr):
    total = 0.0
    for i in range(len(arr)):
        total += arr[i]
    return total
```

### Parallel Execution

```python
import numba

@numba.njit(parallel=True)
def parallel_process(arr):
    result = arr.copy()
    for i in numba.prange(len(arr)):
        result[i] = arr[i] * 2
    return result
```

### Algorithms

See the examples in `examples/numba/` for more complex use cases:
- `default.py` - Simple function
- `generator.py` - Generator functions
- `vectorization.py` - Array operations
- `parallel.py` - Parallel algorithms
- `algorithms.py` - Common algorithms (fibonacci, binary search, etc.)

## How It Works

### Architecture

1. **Compilation**: When you "compile" your Python code:
   - CE saves your code to a temporary file
   - Runs `numba_wrapper.py` which imports your module
   - Module import triggers Numba's JIT compilation
   
2. **Assembly Extraction**: The wrapper script:
   - Finds all public functions decorated with Numba decorators
   - Calls `dispatcher.inspect_asm()` to get the compiled assembly
   - Annotates assembly with source line numbers
   
3. **Post-processing**: The `NumbaCompiler` class:
   - Filters out noise (directives, labels)
   - Decodes Numba's symbol name mangling
   - Maps assembly back to Python source lines

### Symbol Demangling

Numba mangles Python identifiers to valid assembly symbols. For example:
- `<locals>` becomes `_3clocals_3e`
- Special characters are encoded as `_%02x`

The NumbaCompiler automatically decodes these for readability.

## Configuration

### Local Setup

For local testing, create `etc/config/numba.local.properties`:

```ini
compilers=numba_local
compiler.numba_local.exe=/usr/bin/python3
compiler.numba_local.name=Numba (local)

compilerType=numba
supportsExecute=true
```

Then run:
```bash
# Install Numba
pip install numba

# Start CE with only Numba language
make dev EXTRA_ARGS='--language numba'
```

### Production Setup

On godbolt.org, Numba compilers are installed in `/opt/compiler-explorer/numba/` using the infra repository's installation tools.

## Limitations

- **Import-time execution**: Code at module level is executed during import
- **Compilation errors**: Numba compilation errors are shown in the output pane
- **Execution**: You can execute Numba code, but execution uses Python's interpreter (assembly view shows JIT-compiled code)
- **External libraries**: Only libraries available in the CE environment can be imported

## Tips

### Viewing Optimizations

Try different optimization levels and signatures to see how Numba optimizes your code:

```python
import numba

# Without type hints - may be less optimized
@numba.njit
def power_untyped(x, n):
    result = 1
    for _ in range(n):
        result *= x
    return result

# With type hints - better optimization
@numba.njit("float64(float64, int32)")
def power_typed(x, n):
    result = 1.0
    for _ in range(n):
        result *= x
    return result
```

### Comparing to CPython

Use the Python language option to see CPython bytecode, then switch to Numba to compare with native assembly.

### Parallel Performance

Use `parallel=True` and `numba.prange()` to see how Numba generates multi-threaded code:

```python
import numba

@numba.njit(parallel=True)
def parallel_sum(arr):
    total = 0.0
    for i in numba.prange(len(arr)):  # Note: prange not range
        total += arr[i]
    return total
```

## References

- [Numba Documentation](https://numba.readthedocs.io/)
- [Numba Performance Tips](https://numba.readthedocs.io/en/stable/user/performance-tips.html)
- [Supported Python Features](https://numba.readthedocs.io/en/stable/reference/pysupported.html)
- [Supported NumPy Features](https://numba.readthedocs.io/en/stable/reference/numpysupported.html)

## Troubleshooting

### "No module named numba"
The Python interpreter needs Numba installed. For local instances, run `pip install numba`.

### "Cannot determine Numba type"
Some Python features aren't supported by Numba. Check the [supported features list](https://numba.readthedocs.io/en/stable/reference/pysupported.html).

### Empty assembly output
Make sure your functions are decorated with `@numba.jit` or `@numba.njit` and are public (don't start with underscore).

### Complex mangled names
This is normal - Numba uses LLVM-style name mangling. CE automatically simplifies common patterns.
